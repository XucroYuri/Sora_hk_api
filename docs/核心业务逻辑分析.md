# CineFlow 核心业务逻辑分析

**版本**: v1.0
**日期**: 2026-01-02
**文档类型**: 核心逻辑逆向分析

---

## 1. 概述

CineFlow 的核心是一个基于配置驱动的批量视频生成引擎。它通过解析结构化的分镜脚本（Storyboard），自动化地与 Sora API 进行交互，完成 Prompt 增强、任务提交、状态轮询及视频下载的全流程。

## 2. 核心输入 (Input Parameters)

系统的核心输入是遵循特定 Schema 的 JSON 文件（通常命名为 `storyboard*.json`）。

### 2.1 Storyboard 结构
```json
{
  "segments": [ ... ],
  "metadata": { ... },
  "character_bible": [ ... ]
}
```

### 2.2 Segment（核心单元）
每个分镜片段（Segment）包含生成视频所需的所有参数：

| 字段名 | 类型 | 必填 | 描述 | 示例 |
| :--- | :--- | :--- | :--- | :--- |
| `segment_index` | int | 是 | 分镜序号，用于排序和文件命名 | `1` |
| `prompt_text` | str | 是 | 基础提示词，描述画面动作和内容 | `"Alice is walking in the park..."` |
| `image_url` | str | 否 | 参考图 URL (Image-to-Video) | `"https://example.com/ref.jpg"` |
| `is_pro` | bool | 否 | 是否开启 Sora Pro 模式 | `true` |
| `duration_seconds` | int | 否 | 视频时长 (秒) | `10`, `15`, `25` (Pro only) |
| `resolution` | str | 否 | 分辨率 | `"horizontal"` (16:9), `"vertical"` (9:16) |
| `director_intent` | str | 否 | 导演意图，用于微调风格或运镜 | `"Cinematic lighting, low angle shot"` |
| **`asset`** | obj | 否 | 资产信息，用于 Prompt 增强 | 见下文 |

### 2.3 Asset（资产对象）
| 字段名 | 类型 | 描述 |
| :--- | :--- | :--- |
| `characters` | List[Obj] | 角色列表。包含 `name` 和 `id` (Sora Character ID)。<br>例如: `[{"name": "Alice", "id": "@char_123"}]` |
| `scene` | str | 场景描述。例如: `"Cyberpunk city street at night"` |
| `props` | List[str] | 道具列表。例如: `["Neon Umbrella", "Vintage Camera"]` |

---

## 3. 核心输出 (Output Format)

系统为每个生成任务产生两个核心文件，存储在 `output_dir` 下：

### 3.1 视频文件 (.mp4)
*   **命名格式**: `{segment_index}_v{version}_{timestamp}_{suffix}_{task_id}.mp4`
*   **内容**: 从 Sora API 下载的最终视频文件。

### 3.2 元数据文件 (.json)
*   **命名格式**: 同视频文件，后缀为 `.json`。
*   **内容**: 包含任务执行的完整上下文信息，包括：
    *   API 响应状态 (`status`, `progress`)
    *   最终使用的完整 Prompt
    *   视频下载链接 (`video_url`)
    *   任务 ID (`id`)
    *   错误信息（如果有）

---

## 4. 核心业务逻辑流程

### 4.1 任务发现与初始化 (Discovery)
1.  **扫描**: 递归扫描输入目录下的 `storyboard*.json` 文件。
2.  **解析**: 利用 Pydantic (`Storyboard` 模型) 校验 JSON 格式。
3.  **裂变**: 根据配置的 `gen_count`（每段生成数量），将一个 `Segment` 裂变为 N 个独立的 `GenerationTask`。
4.  **目录规划**: 自动计算输出路径，通常按 `Project / Storyboard / Segment_X` 层级组织。

### 4.2 Prompt 工程化增强 (Prompt Engineering)
在提交任务前，系统会对原始 Prompt 进行复杂的预处理：

1.  **角色 ID 注入 (Character Injection)**:
    *   扫描 `asset.characters` 列表。
    *   在 `prompt_text` 中查找角色名。
    *   **替换逻辑**: 将人名替换为 Sora 专用 ID (如 `Alice` -> `@char_123 `)。
    *   **智能模式**: 支持 `[Alice]` 显式标记（Strict Mode）或自动匹配（Legacy Mode）。
2.  **上下文拼接**:
    *   将 `asset.scene` (场景)、`asset.props` (道具)、`director_intent` (导演意图) 格式化后追加到 Prompt 末尾。
3.  **格式清洗**:
    *   强制在 `@ID` 前后添加空格，确保分词正确。
    *   去除多余的空白字符。

### 4.3 任务执行生命周期 (Execution Lifecycle)
单个任务 (`process_task`) 的执行流程如下：

1.  **跳过检查**: 检查输出文件是否已存在且非空。
2.  **并发控制**: 申请信号量，确保并发数不超过系统限制（如 20）。
3.  **API 提交 (Submit)**:
    *   调用 `client.create_task`。
    *   处理 Rate Limit（429）和网络错误，执行指数退避重试。
4.  **状态轮询 (Polling)**:
    *   每隔 `POLL_INTERVAL` (10s) 查询一次任务状态。
    *   最大等待时间 `MAX_POLL_TIME` (默认 35 分钟)。
    *   **终止条件**: 状态变为 `completed` 或 `failed`。
5.  **结果处理**:
    *   **成功**: 下载视频流到本地文件，保存元数据 JSON。
    *   **失败**: 记录错误日志，保存包含错误信息的元数据。
    *   **下载异常**: 若视频生成成功但下载失败，**不**重试生成，仅保存元数据（保留 `video_url` 供人工补救）。

---

## 5. 异常处理策略

*   **API 错误**: 自动重试 3 次，并在日志中脱敏记录错误详情。
*   **网络抖动**: `requests.Session` 配置了底层 TCP 重试。
*   **僵尸任务**: 轮询超时后标记为失败，防止无限等待。
*   **数据安全**: 日志过滤器 (`SensitiveFilter`) 自动屏蔽 API Key。
